# 卧槽，我好像会生命周期了

现在才搞懂这个是不是有点晚啊？

平常少点摸鱼，这种东西早就学会了...

## 生命周期？你妈的，为什么？

为什么Rust要有“生命周期”？有就算了，为什么还要把语法和概念整得这么抽象？说好的“赋予每个人构建可靠且高效软件能力”呢？

别急，我一开始也不懂。说是什么为了内存安全、防止指针垂悬（悬垂？）这个那个的，这么解释属实是“懂的人都懂，不懂的人不必懂”了。我个人认为这样解释只能算“同义反复”，而没有点出真正的关键。

## “无语。跟你说不下去，典型的GC语言思维。”

如果你以前接触过C或是C++（没学过指针不算接触过），“生命周期”这个词你一听就明白，压根不需要解释。为什么？这类语言没有垃圾回收器（Garbage Collector, GC），开发者需要自行管理内存的分配和释放。这同时也意味着，在引用某一数据时，开发者需要首先知道这个数据有没有被销毁，再进行引用。否则就会出现刚才提到的“悬垂指针”问题。

*对于有GC的语言来说，GC会尝试自动回收由程序分配但不再被引用的内存。也就是说，你（几乎）可以任意引用内存而无须关心那部分内存应该在何时被释放。（特定情况除外）*  
*如你所见，GC真是省事的个好东西。它帮开发者自动管理内存，避免了（最严重的）内存安全问题，还为编程提供了更大的灵活性。  
那么，代价是什么呢？很简单，更大的性能开销。GC需要耗费额外的计算资源来跟踪对象并决定释放哪些内存。只要看看C/C++相比其他语言在相同场景下的性能表现你就知道了。*

>一个在栈上的数据的生命周期是保证它在栈上同一个位置的时间段；换句话说，生命周期是保证对该数据的引用（指针）不会变得无效的时间段。  
[第14条：理解生命周期 - Effective Rust 中文版 #生命周期的作用域](https://rustx-labs.github.io/effective-rust-cn/chapter_3/item14-lifetimes.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F)

这个定义很好地解释了生命周期的本质，但也引出了一些现实问题...

1. 我要如何确保我自己知道某个变量有没有被释放？
2. 我要如何确保自己写出的代码严格按预期释放内存，以便于我在其他地方放心地引用变量？
3. 我要如何让其他与我合作的开发者知道我的代码中的变量在何时被释放？

在C和C++中，解决方法...其实这俩语言没给你解决方法。它们都直接给你裸指针了，你想怎么搞就怎么搞，它们不管的。但这种自由度带来的是不安全性，因为你不知道会不会有二百五拿指针乱指。

而Rust作为一门强调内存安全的现代编程语言，自然也非常自觉地 (nobody asked though) 肩负起了解决这些问题的使命。于是，Rust创造了自己的"生命周期"概念来在编译期保证内存安全。

## Talk is cheap. Show me the code.

*此处默认读者已经对Rust的作用域和借用检查器等基础概念有充分了解。如果你不了解，去读《Rust程序设计语言》，读完相关部分再回来。*

考虑这样一种情况：
```rust
struct Container {
    data: String
}

impl Container {
    fn get_data(&self) -> String {
        self.data
    }
}
```
你写完了以上代码，但编译器却不太开心：
```
error[E0507]: cannot move out of `self.data` which is behind a shared reference
 --> main.rs:7:9
  |
7 |         self.data
  |         ^^^^^^^^^ move occurs because `self.data` has type `String`, which does not implement the `Copy` trait
  |
help: consider cloning the value if the performance cost is acceptable
  |
7 |         self.data.clone()
  |                  ++++++++
```
你也看不太懂编译器想表达什么，不过编译器倒是给出了明确的解决方案：加个`clone()`。你照做了，编译器果然不再多嘴。代码运行得很好，你很开心。

**为什么加一个clone()就可以解决问题？编译器的报错到底是什么意思？**


在`get_data()`方法的签名中，我们使用了`&self`而不是`self`，因为我们不希望执行这个方法会消费掉这个结构体（这种消费性的方法并不常见，除非你希望将`self`转变成别的结构体，比如某种`into()`方法）。但这也同时意味着，这个方法并不拥有`self`的所有权，它仅借用了`self`，因此也就无法将其内部字段的所有权转移出去（而函数/方法的返回值会发生所有权转移）。这就是编译器报错的原因。

`clone()`方法的作用很简单：将原值完整地复制出一份新值。复制操作并不需要原值的所有权，但会产生一个全新的、独立的值，并获得这个新值的所有权。因为此时内存中同时存在两个完全独立的值，对其中一个值的修改不会影响另一个值。这样我们就可以安全地将这个新值返回。

**那么，问题在哪？**

其实编译器提示过了：**consider** cloning the value **if the performance cost is acceptable**. *如果性能开销可接受，请考虑cloning（克隆）。* `clone()`是有开销的。其实就算不考虑开销，你肯定也能发现，很多这样的情况其实没有必要进行复制。只要能确保原值在我们使用时一直存在，对原值的引用就能一直有效，我们也就可以返回值的引用，而不是返回值本身。

让我们把刚才的代码改进一下。

```rust
struct Container<'a, 'b: 'a> {
    data: &'b str,
    _lifetime: std::marker::PhantomData<&'a ()>
}

impl<'a, 'b: 'a> Container<'a, 'b> {
    fn get_data(&'a self) -> &'b str {
        self.data
    }
}
```

在以上代码中，我们将`data`的类型改为`str`，同时给`Container`结构体与其方法添加了生命周期标注。

新东西有点多，我们慢慢看。首先是结构体声明：

```rust
struct Container<'a, 'b: 'a> {
    data: &'b str,
    _lifetime: std::marker::PhantomData<&'a ()>
}
```

这个~~丑陋的~~`<'a, 'b: 'a>`就是Rust的结构体生命周期参数了。它跟在结构体名后面，声明了两个生命周期标注`'a`和`'b`，其中`'b: 'a`表示`'b`的生命周期长度大于等于`'a`的生命周期长度。也就是说，通过这个声明，我们告诉编译器：`'a`标注的对象会在`'b`标注的对象被销毁之前被销毁。

有点抽象？那我用更抽象的话再来解释一遍：铁打的`'b`，流水的`'a`。

好的，不管你有没有理解，接着往下看：在声明完生命周期标注之后，我们就可以在结构体内部使用它们了。我们把`'b`标注到`data`上，告诉编译器`data`对应的生命周期。

*那我问你那我问你那我问你，这个`_lifetime`是什么？*

*~~这是用来让rust-analyzer闭嘴的东西~~* `PhantomData<T>`是一个零大小的类型，专门用于告诉编译器