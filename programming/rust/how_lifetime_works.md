# 卧槽，我好像会生命周期了

现在才搞懂这个是不是有点晚啊？

平常少点摸鱼，这种东西早就学会了...

## 生命周期？你妈的，为什么？

为什么Rust要有“生命周期”？有就算了，为什么还要把语法和概念整得这么抽象？说好的“赋予每个人构建可靠且高效软件能力”呢？

别急，我一开始也不懂。说是什么为了内存安全、防止指针垂悬（悬垂？）这个那个的，这么解释属实是“懂的人都懂，不懂的人不必懂”了。我个人认为这样解释只能算同义反复，而没有点出真正的关键。

## 无语，跟你说不下去，典型的GC语言思维

如果你以前接触过C或是C++（没学过指针不算接触过），“生命周期”这个词你一听就明白，压根不需要解释。为什么？这类语言没有垃圾回收器（Garbage Collector, GC），这意味着开发者需要自行管理内存的分配和释放。这同时也意味着，在引用内存时，开发者需要首先知道这片内存有没有被释放掉，再进行引用。

*对于有GC的语言来说，所有内存都由GC来自动管理。你可以任意引用任何内存，只有被GC确认没有被引用的内存才会被释放掉。因此，你才可以在这类语言中随便使用变量，而无须关心其他事情。（特定情况除外）*  
*如你所见，GC真是省事的个好东西。它帮开发者自动管理内存，避免了内存安全问题，还为编程提供了更大的灵活性。那么，代价是什么呢？很简单，更大的性能开销。GC需要耗费一定的计算资源来决定释放哪些内存。只要看看C/C++相比其他语言的性能你就知道了。*

一个变量的生命周期，指的就是变量在内存中存在的时间周期（它将在什么时候、或是什么情况下被释放掉）。

如你所见，这带来了一些问题...

1. 我要如何知道某个变量有没有被释放？
2. 我要如何确保自己写出的代码严格按预期释放内存，以便于我在其他地方放心地引用变量？
3. 我要如何让其他与我合作的开发者知道我的代码中的变量在何时被释放？

在C和C++中，解决方法...其实这俩语言没给你解决方法。它们都直接给你裸指针了，你想怎么搞就怎么搞，它们不管的。

而Rust作为一门强调内存安全的编程语言，自然也非常自觉地（没人问地）肩负起了解决这些问题的使命。于是，就有了生命周期标注。

## Talk is cheap. Show me the code.

*此处默认读者已经对Rust的作用域和借用检查器等基础概念有充分了解。如果你不了解，去读《Rust程序设计语言》，读完相关部分再回来。*

考虑这样一种情况：
```rust
struct Container {
    data: String
}

impl Container {
    fn get_data(&self) -> String {
        self.data
    }
}
```
你写完了以上代码，但编译器却不太开心：
```
error[E0507]: cannot move out of `self.data` which is behind a shared reference
 --> main.rs:7:9
  |
7 |         self.data
  |         ^^^^^^^^^ move occurs because `self.data` has type `String`, which does not implement the `Copy` trait
  |
help: consider cloning the value if the performance cost is acceptable
  |
7 |         self.data.clone()
  |                  ++++++++
```
你也看不太懂编译器想表达什么，不过编译器倒是给出了明确的解决方案：加个`clone()`。你照做了，编译器果然不再多嘴。代码运行得很好，你很开心。

**为什么加一个clone()就可以解决问题？编译器的报错到底是什么意思？**

在`get_data()`方法的签名中，我们在参数中使用了`&self`而不是`self`，因为我们不希望执行这个方法会消费掉这个结构体（实际上这种需求也并非常见，除非你希望将`self`转变成别的结构体）。但这也同时意味着，这个方法并不拥有`self`的所有权，它仅借用了`self`，也就更无法将其所有权转移到别处（函数/方法会转移返回值的所有权）。因此，编译器就报错了。

`clone()`方法所做的很简单：将原值一比一复制出一份新值。复制并不需要原值的所有权，却可以获得复制得到的新值的所有权。因为此时内存中同时存在两个值，两值互相独立，对其中一值进行修改不会影响另一值。此时你便可以将这个新值返回。

**那么，问题在哪？**

其实编译器提示过了：**consider** cloning the value **if the performance cost is acceptable**. `clone()`是有开销的。



